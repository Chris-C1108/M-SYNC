# M-SYNC 跨设备实时消息同步系统

## 组件命名规范与架构优化

### 1. 系统架构概述

**M-SYNC** (Multi-device Synchronization) 是一个基于发布-订阅模式的跨设备实时消息同步系统。

#### 1.1 核心组件命名

| 原命名 | 优化后命名 | 英文标识 | 职责描述 |
|--------|------------|----------|----------|
| 消息产生端 | **消息发布端** | `MessagePublisher` | 负责消息的产生和发布 |
| 服务端 | **消息代理服务** | `MessageBrokerService` | 负责消息路由和分发 |
| PC端 | **消息订阅端** | `MessageSubscriber` | 负责消息接收和处理 |
| Webhook接口 | **消息接入网关** | `MessageIngressGateway` | HTTP消息接收端点 |
| WebSocket模块 | **实时消息分发器** | `RealtimeMessageDispatcher` | WebSocket消息推送服务 |

### 2. 系统需求分析与架构挑战

这是一个典型的**跨设备实时消息同步系统**，核心是将移动端（iOS设备）的消息事件实时同步到桌面端（PC）。

#### 2.1 消息发布端 (MessagePublisher - iOS Shortcuts)
**技术约束**:
- **无状态特性**: iOS Shortcuts 作为脚本执行器，无法维持持久连接
- **认证限制**: 采用 **API Token** 进行静态认证
- **消息协议**: 支持结构化消息格式（TEXT、URL、CODE类型）

#### 2.2 消息代理服务 (MessageBrokerService)
**核心职责**:
- **双接口架构**: HTTP接入 + WebSocket分发
- **消息路由**: 基于用户ID的多租户消息隔离
- **连接管理**: 维护活跃连接池和心跳检测

#### 2.3 消息订阅端 (MessageSubscriber - Desktop Agent)
**核心功能**:
- **持久连接**: 维持与代理服务的长连接
- **消息处理**: 根据消息类型执行系统操作
- **故障恢复**: 自动重连和错误处理

### 3. 详细架构设计

#### 3.1 消息流架构

```
[iOS Shortcuts] --HTTP POST--> [MessageIngressGateway] 
                                        |
                                        v
                               [MessageBrokerService]
                                        |
                                        v
                              [RealtimeMessageDispatcher] --WebSocket--> [Desktop Agent]
```

#### 3.2 消息发布端 (iOS Shortcuts)

**组件标识**: `ios-shortcuts-publisher`

**配置参数**:
```json
{
  "endpoint": "https://api.m-sync.com/v1/messages/publish",
  "apiToken": "${USER_API_TOKEN}",
  "messageSchema": {
    "token": "string",
    "messageType": "TEXT|URL|CODE", 
    "content": "string",
    "timestamp": "ISO8601"
  }
}
```

**实现要点**:
- 使用 `Get Contents of URL` 动作
- 请求方法: `POST`
- 内容类型: `application/json`
- 认证方式: Bearer Token

#### 3.3 消息代理服务 (MessageBrokerService)

**服务标识**: `message-broker-service`
**技术栈**: Node.js + Express + ws

##### 3.3.1 消息接入网关 (MessageIngressGateway)

**端点定义**:
- **路径**: `/api/v1/messages/publish`
- **方法**: `POST`
- **认证**: API Token验证
- **限流**: 100 req/min per token

**核心逻辑**:
```javascript
// 消息接收处理器
class MessageIngressHandler {
  async handlePublish(request) {
    const { token, messageType, content } = request.body;
    
    // 1. Token验证
    const userId = await this.authenticateToken(token);
    
    // 2. 消息验证
    const message = await this.validateMessage(messageType, content);
    
    // 3. 消息路由
    await this.routeMessage(userId, message);
  }
}
```

##### 3.3.2 实时消息分发器 (RealtimeMessageDispatcher)

**WebSocket端点**: `wss://api.m-sync.com/ws/subscribe`

**连接管理**:
```javascript
// 连接池管理器
class ConnectionPoolManager {
  constructor() {
    this.connections = new Map(); // userId -> Set<WebSocket>
    this.heartbeatInterval = 30000; // 30秒心跳
  }
  
  addConnection(userId, websocket) {
    if (!this.connections.has(userId)) {
      this.connections.set(userId, new Set());
    }
    this.connections.get(userId).add(websocket);
  }
  
  async broadcastToUser(userId, message) {
    const userConnections = this.connections.get(userId);
    if (userConnections) {
      const promises = Array.from(userConnections).map(ws => 
        this.sendMessage(ws, message)
      );
      await Promise.allSettled(promises);
    }
  }
}
```

#### 3.4 消息订阅端 (Desktop Agent)

**服务标识**: `desktop-message-subscriber`
**技术栈**: Node.js CLI Application

**配置文件** (`config.json`):
```json
{
  "brokerService": {
    "wsEndpoint": "wss://api.m-sync.com/ws/subscribe",
    "authToken": "${JWT_TOKEN}",
    "reconnectInterval": 5000,
    "heartbeatInterval": 30000
  },
  "messageHandlers": {
    "TEXT": "clipboard",
    "CODE": "clipboard", 
    "URL": "browser"
  },
  "logging": {
    "level": "info",
    "file": "./logs/subscriber.log"
  }
}
```

**核心组件**:
```javascript
// 消息订阅客户端
class MessageSubscriberClient {
  constructor(config) {
    this.config = config;
    this.messageHandlers = new MessageHandlerRegistry();
    this.connectionManager = new WebSocketConnectionManager();
  }
  
  async start() {
    await this.connectionManager.connect(this.config.brokerService);
    this.connectionManager.on('message', this.handleMessage.bind(this));
  }
  
  async handleMessage(message) {
    const handler = this.messageHandlers.getHandler(message.type);
    await handler.process(message.content);
  }
}
```

### 4. 数据模型与接口规范

#### 4.1 消息协议定义

**消息发布协议** (`MessagePublishRequest`):
```typescript
interface MessagePublishRequest {
  token: string;           // API认证令牌
  messageType: MessageType; // 消息类型枚举
  content: string;         // 消息内容
  timestamp?: string;      // 可选时间戳
  metadata?: object;       // 可选元数据
}

enum MessageType {
  TEXT = 'TEXT',
  URL = 'URL', 
  CODE = 'CODE'
}
```

**消息分发协议** (`MessageDispatchEvent`):
```typescript
interface MessageDispatchEvent {
  messageId: string;       // 消息唯一标识
  messageType: MessageType; // 消息类型
  content: string;         // 消息内容
  timestamp: string;       // 服务器时间戳
  publisherId: string;     // 发布者标识
}
```

#### 4.2 配置管理规范

**环境变量命名**:
```bash
# 消息代理服务
MSYNC_BROKER_PORT=3000
MSYNC_BROKER_HOST=0.0.0.0
MSYNC_DB_CONNECTION_STRING=sqlite:./data/msync.db
MSYNC_REDIS_URL=redis://localhost:6379
MSYNC_JWT_SECRET=your-jwt-secret
MSYNC_API_TOKEN_EXPIRY=7d

# 桌面订阅端
MSYNC_SUBSCRIBER_WS_ENDPOINT=wss://api.m-sync.com/ws/subscribe
MSYNC_SUBSCRIBER_AUTH_TOKEN=your-jwt-token
MSYNC_SUBSCRIBER_LOG_LEVEL=info
```

### 5. 部署与运维规范

#### 5.1 服务命名规范

**Docker容器命名**:
- 消息代理服务: `msync-broker-service`
- 数据库服务: `msync-database`
- Redis缓存: `msync-redis-cache`

**系统服务命名**:
- Windows: `MSyncDesktopSubscriber`
- macOS: `com.msync.desktop-subscriber`
- Linux: `msync-desktop-subscriber.service`

#### 5.2 日志规范

**日志组件标识**:
```javascript
const logger = {
  broker: createLogger('MessageBrokerService'),
  gateway: createLogger('MessageIngressGateway'), 
  dispatcher: createLogger('RealtimeMessageDispatcher'),
  subscriber: createLogger('MessageSubscriber')
};
```

### 6. 总结

通过专业化的组件命名和架构设计，M-SYNC系统具备了以下特点：

1. **清晰的职责分离**: 每个组件都有明确的英文标识和职责定义
2. **标准化的接口**: 采用RESTful API和WebSocket标准协议
3. **可扩展的架构**: 支持多租户和水平扩展
4. **完善的配置管理**: 统一的环境变量和配置文件规范
5. **专业的运维支持**: 标准化的服务命名和日志管理

这套命名规范确保了系统的专业性、可维护性和可扩展性。
